<!DOCTYPE html>
<html>
  <head>
    <link rel="icon" type="image/png" href="/views/in_race_livestream/sso-logo.png">
    <link rel="stylesheet" href="/views/in_race_livestream/styles.css">
  </head>
  <body>
    <div class="race-clock" id="race-clock">00:00.0</div>
    
    <div class="sso-logo">
      <img src="/views/in_race_livestream/sso-logo.png" alt="SSO Logo">
    </div>
    
    <div class="racer-grid" id="racer-grid">
      <!-- Racers will be populated by JavaScript -->
    </div>
    
    <!-- HTML5 Template for racer cards -->
    <template id="racer-template">
      <div class="racer-card">
        <div class="position"></div>
        <div class="color-indicator"></div>
        <div class="racer-info">
          <div class="racer-name"></div>
          <div class="affiliation"></div>
        </div>
        <div class="time"></div>
        <div class="lap-count"></div>
      </div>
    </template>
    
    <script>
      // Configuration
      const UPDATE_INTERVAL = 250; // milliseconds
      const SORT_BY = 'place'; // 'place' or 'lane'
      
      // Lane color mapping
      const LANE_COLORS = {
        1: '#ffff00',  // Yellow
        2: '#000000',  // Black
        3: '#00ffff',  // Light Blue
        4: '#ff0000',  // Red
        5: '#ffffff',  // White
        6: '#000080',  // Navy Blue
        7: '#808080',  // Grey
        8: '#ffc0cb',  // Pink
        9: '#ffa500',  // Orange
        10: '#008000'  // Green
      };
      
      function formatTime(timeSpanString) {
        if (!timeSpanString) return '00:00.000';
        
        // TimeSpan is serialized as "HH:mm:ss.fffffff" format
        // We need to parse it and format as "mm:ss.fff"
        const parts = timeSpanString.split(':');
        if (parts.length !== 3) return '00:00.000';
        
        const hours = parseInt(parts[0]) || 0;
        const minutes = parseInt(parts[1]) || 0;
        const secondsParts = parts[2].split('.');
        const seconds = parseInt(secondsParts[0]) || 0;
        
        // Handle the fractional seconds part (7 digits)
        let milliseconds = 0;
        if (secondsParts[1]) {
          const fractionalPart = secondsParts[1].padEnd(7, '0');
          milliseconds = Math.floor(parseInt(fractionalPart.substring(0, 3)) || 0);
        }
        
        const totalMinutes = hours * 60 + minutes;
        const formattedMinutes = totalMinutes.toString().padStart(2, '0');
        const formattedSeconds = seconds.toString().padStart(2, '0');
        const formattedMilliseconds = milliseconds.toString().padStart(3, '0');
        
        return `${formattedMinutes}:${formattedSeconds}.${formattedMilliseconds}`;
      }
      
      function formatRaceTime(timeSpanString) {
        if (!timeSpanString) return '00:00.0';
        
        // TimeSpan is serialized as "HH:mm:ss.fffffff" format
        // We need to parse it and format as "mm:ss.f"
        const parts = timeSpanString.split(':');
        if (parts.length !== 3) return '00:00.0';
        
        const hours = parseInt(parts[0]) || 0;
        const minutes = parseInt(parts[1]) || 0;
        const secondsParts = parts[2].split('.');
        const seconds = parseInt(secondsParts[0]) || 0;
        
        // Handle the fractional seconds part (7 digits) - take first digit for tenths
        let tenths = 0;
        if (secondsParts[1]) {
          const fractionalPart = secondsParts[1].padEnd(7, '0');
          tenths = Math.floor(parseInt(fractionalPart.substring(0, 1)) || 0);
        }
        
        const totalMinutes = hours * 60 + minutes;
        const formattedMinutes = totalMinutes.toString().padStart(2, '0');
        const formattedSeconds = seconds.toString().padStart(2, '0');
        
        return `${formattedMinutes}:${formattedSeconds}.${tenths}`;
      }
      
      function getLaneColor(lane) {
        return LANE_COLORS[lane] || '#333333';
      }
      
      function formatLapsDisplay(lapsRemaining, raceStatus, halfLapModeEnabled, hasFirstCrossing) {
        if (lapsRemaining === null || lapsRemaining === undefined) {
          return '-';
        }
        
        let displayValue = lapsRemaining;
        
        // Apply half-lap mode display logic
        if (halfLapModeEnabled) {
          if (raceStatus === 'NotStarted' || raceStatus === 0) {
            // Before race starts, show the actual value (including half laps)
            displayValue = lapsRemaining;
          } else {
            // After race starts, check if this is a half-lap race
            if (lapsRemaining % 1 === 0.5) {
              // Half-lap race: show the whole number part (visually remove the 1/2)
              displayValue = Math.floor(lapsRemaining);
            } else {
              // Whole lap race: always subtract 1 after race starts
              displayValue = lapsRemaining - 1;
              
              // If the value would be negative, show hyphen
              if (displayValue < 0) {
                return '-';
              }
            }
          }
        } else {
          // Half-lap mode disabled: always subtract 1 from display value
          displayValue = lapsRemaining - 1;
          
          // If the value would be negative, show hyphen
          if (displayValue < 0) {
            return '-';
          }
        }
        
        // If race has started (Running, Paused, or Finished), only show whole numbers
        if (raceStatus === 'Running' || raceStatus === 'Paused' || raceStatus === 'Finished') {
          return Math.floor(displayValue).toString();
        }
        
        // Before race starts, show decimal values including half laps
        if (displayValue % 1 === 0.5) {
          // Show as "13 1/2" format for half laps
          const wholePart = Math.floor(displayValue);
          return wholePart + ' 1/2';
        }
        
        // Show as decimal for other cases
        return displayValue.toString();
      }
      
      function createLapsDisplayHTML(lapsRemaining, raceStatus, halfLapModeEnabled, hasFirstCrossing) {
        if (lapsRemaining === null || lapsRemaining === undefined) {
          return '-';
        }
        
        // Apply half-lap mode display logic
        let displayValue = lapsRemaining;
        
        if (halfLapModeEnabled) {
          if (raceStatus === 'NotStarted' || raceStatus === 0) {
            // Before race starts, show the actual value (including half laps)
            displayValue = lapsRemaining;
          } else {
            // After race starts, check if this is a half-lap race
            if (lapsRemaining % 1 === 0.5) {
              // Half-lap race: show the whole number part (visually remove the 1/2)
              displayValue = Math.floor(lapsRemaining);
            } else {
              // Whole lap race: always subtract 1 after race starts
              displayValue = lapsRemaining - 1;
              
              // If the value would be negative, show hyphen
              if (displayValue < 0) {
                return '-';
              }
            }
          }
        } else {
          // Half-lap mode disabled: always subtract 1 from display value
          displayValue = lapsRemaining - 1;
          
          // If the value would be negative, show hyphen
          if (displayValue < 0) {
            return '-';
          }
        }
        
        // If race has started (Running, Paused, or Finished), only show whole numbers
        if (raceStatus === 'Running' || raceStatus === 'Paused' || raceStatus === 'Finished') {
          return Math.floor(displayValue).toString();
        }
        
        // Before race starts, show decimal values including half laps
        if (displayValue % 1 === 0.5) {
          // Show as "13" with small "1/2" for half laps
          const wholePart = Math.floor(displayValue);
          return `${wholePart}<span class="half-lap-fraction">1/2</span>`;
        }
        
        // Show as decimal for other cases
        return displayValue.toString();
      }
      
      function createRacerCard(racer, raceStatus, halfLapModeEnabled) {
        const template = document.getElementById('racer-template');
        const clone = template.content.cloneNode(true);
        
        // Populate the cloned template
        clone.querySelector('.position').textContent = racer.place > 0 ? racer.place : '-';
        clone.querySelector('.color-indicator').style.backgroundColor = getLaneColor(racer.lane);
        clone.querySelector('.racer-name').textContent = racer.name || '-';
        clone.querySelector('.affiliation').textContent = racer.affiliation || '-';
        clone.querySelector('.time').textContent = formatTime(racer.cumulativeSplitTime);
        
        const lapCountElement = clone.querySelector('.lap-count');
        const isHalfLap = racer.delayedLapsRemaining !== null && 
                         racer.delayedLapsRemaining !== undefined && 
                         racer.delayedLapsRemaining % 1 === 0.5 && 
                         (raceStatus === 'NotStarted' || raceStatus === 0);
        
        if (isHalfLap) {
          lapCountElement.innerHTML = createLapsDisplayHTML(racer.delayedLapsRemaining, raceStatus, halfLapModeEnabled, racer.hasFirstCrossing);
          lapCountElement.classList.add('half-lap');
        } else {
          lapCountElement.textContent = formatLapsDisplay(racer.delayedLapsRemaining, raceStatus, halfLapModeEnabled, racer.hasFirstCrossing);
        }
        
        return clone;
      }
      
      function createEmptyRacerCard() {
        const template = document.getElementById('racer-template');
        const clone = template.content.cloneNode(true);
        
        // Create empty card with no content
        clone.querySelector('.position').textContent = '';
        clone.querySelector('.color-indicator').style.backgroundColor = 'transparent';
        clone.querySelector('.racer-name').textContent = '';
        clone.querySelector('.affiliation').textContent = '';
        clone.querySelector('.time').textContent = '';
        clone.querySelector('.lap-count').textContent = '';
        
        // Add a class to identify empty cards for styling
        clone.querySelector('.racer-card').classList.add('empty-card');
        
        return clone;
      }
      
      function createRacerRow(racers, raceStatus, halfLapModeEnabled) {
        const row = document.createElement('div');
        row.className = 'racer-row';
        
        // Add racer cards (up to 4)
        for (let i = 0; i < 4; i++) {
          if (i < racers.length) {
            row.appendChild(createRacerCard(racers[i], raceStatus, halfLapModeEnabled));
          } else {
            row.appendChild(createEmptyRacerCard());
          }
        }
        
        return row;
      }
      
      function positionRaceClock() {
        const racerGrid = document.getElementById('racer-grid');
        const raceClock = document.getElementById('race-clock');
        
        if (racerGrid && raceClock) {
          const gridRect = racerGrid.getBoundingClientRect();
          const clockHeight = 50; // Height of the race clock (reduced for compact layout)
          const spacing = 15; // Space between clock and grid
          const clockWidth = 240; // Width of the race clock
          
          // Position clock above the grid, aligned to the right edge of the grid
          raceClock.style.position = 'fixed';
          raceClock.style.top = (gridRect.top - clockHeight - spacing) + 'px';
          raceClock.style.right = (window.innerWidth - gridRect.right) + 'px'; // Align with grid's right edge
          raceClock.style.bottom = 'auto';
        }
      }
      
      function updateRaceData() {
        fetch(`/api/race/race-data?sortBy=${SORT_BY}`)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            // Update race clock
            document.getElementById('race-clock').textContent = formatRaceTime(data.currentTime);
            
            // Update racer grid
            const racerGrid = document.getElementById('racer-grid');
            racerGrid.innerHTML = '';
            
            // Only display racers that are actually in the race
            const activeRacers = data.racers.filter(racer => racer.lane > 0);
            const halfLapModeEnabled = data.halfLapModeEnabled || false;
            
            // Group racers into rows based on count
            if (activeRacers.length <= 4) {
              // Single row for 1-4 racers
              racerGrid.appendChild(createRacerRow(activeRacers, data.status, halfLapModeEnabled));
            } else if (activeRacers.length <= 8) {
              // First row with 4 racers, second row with remainder
              const firstRow = activeRacers.slice(0, 4);
              const secondRow = activeRacers.slice(4);
              racerGrid.appendChild(createRacerRow(firstRow, data.status, halfLapModeEnabled));
              racerGrid.appendChild(createRacerRow(secondRow, data.status, halfLapModeEnabled));
            } else {
              // First two rows with 4 racers each, third row with remainder
              const firstRow = activeRacers.slice(0, 4);
              const secondRow = activeRacers.slice(4, 8);
              const thirdRow = activeRacers.slice(8);
              racerGrid.appendChild(createRacerRow(firstRow, data.status, halfLapModeEnabled));
              racerGrid.appendChild(createRacerRow(secondRow, data.status, halfLapModeEnabled));
              racerGrid.appendChild(createRacerRow(thirdRow, data.status, halfLapModeEnabled));
            }
            
            // Position race clock dynamically above the racer grid
            positionRaceClock();
          })
          .catch(error => {
            console.error('Error fetching race data:', error);
          });
      }
      
      // Start updating
      updateRaceData(); // Initial load
      setInterval(updateRaceData, UPDATE_INTERVAL);
    </script>
  </body>
</html>
